{"/home/travis/build/npmtest/node-npmtest-haibu/test.js":"/* istanbul instrument in package npmtest_haibu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-haibu/lib.npmtest_haibu.js":"/* istanbul instrument in package npmtest_haibu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_haibu = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_haibu = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-haibu/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-haibu && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_haibu */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_haibu\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_haibu.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_haibu.rollup.js'] =\n            local.assetsDict['/assets.npmtest_haibu.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_haibu.__dirname + '/lib.npmtest_haibu.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu.js":"/*\n * haibu.js: Top level include for the haibu module\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    flatiron = require('flatiron'),\n    semver = require('semver');\n\nvar haibu = module.exports = new flatiron.App({\n  delimiter: ':',\n  root: path.join(__dirname, '..'),\n  directories: {\n    apps: '#ROOT/local',\n    autostart: '#ROOT/autostart',\n    config: '#ROOT/config',\n    packages: '#ROOT/packages',\n    tmp: '#ROOT/tmp'\n  }\n});\n\nhaibu.use(flatiron.plugins.exceptions);\n\n//\n// Expose version through `pkginfo`.\n//\nrequire('pkginfo')(module, 'version');\n\n//\n// Set the allowed executables\n//\nhaibu.config.set('allowedExecutables', ['node', 'coffee']);\n\nhaibu.common     = haibu.utils = require('./haibu/common');\nhaibu.Spawner    = require('./haibu/core/spawner').Spawner;\nhaibu.repository = require('./haibu/repositories');\nhaibu.drone      = require('./haibu/drone');\nhaibu.running    = {};\n\nhaibu.sendResponse = function sendResponse(res, status, body) {\n  return res.json(status, body);\n};\n\n//\n// Expose the relevant plugins as lazy-loaded getters\n//\n['coffee', 'advanced-replies', 'useraccounts'].forEach(function (plugin) {\n  haibu.__defineGetter__(plugin, function () {\n    return require('./haibu/plugins/' + plugin);\n  });\n})","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/common/index.js":"/*\n * index.js: Top level module include for utils module.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar crypto = require('crypto'),\n    fs = require('fs'),\n    http = require('http'),\n    os = require('os'),\n    path = require('path'),\n    spawn = require('child_process').spawn,\n    flatiron = require('flatiron'),\n    async = flatiron.common.async,\n    rimraf = flatiron.common.rimraf,\n    haibu = require('../../haibu');\n\nvar common = module.exports = flatiron.common;\n\n//\n// **REALLY DONT DO THIS HERE! But where?**\n//\nif (!Error.prototype.toJSON) {\n  Object.defineProperty(Error.prototype, \"toJSON\", { \n    enumerable: false, \n    value: function () { \n      return flatiron.common.mixin({ \n        message: this.message, \n        stack: this.stack, \n        arguments: this.arguments\n      }, flatiron.common.clone(this));\n    } \n  });\n}\n\n//\n// ### Include Exports\n// Export additional common components\n//\nvar npm = common.npm = require('./npm');\n\ncommon.welcome = [\n  '      __                  __               '.yellow,\n  '     / /_    ______  __  / /_     __  __   '.yellow,\n  '    / __ \\\\  / __  / / / /  __ \\\\  / / / /   '.yellow,\n  '   / / / / / /_/ / / / /  /_/ / / /_/ /    '.yellow,\n  '  /_/ /_/  \\\\__,_/ /_/ /_/\\\\___/  \\\\__,_/     '.yellow,\n  '  ',\n  '  This is Open Source Software available under'.grey,\n  '  the MIT License.'.grey,\n  '  ',\n  ('  © ' + (new Date()).getFullYear() + ' Nodejitsu Inc.').grey,\n  '  All Rights Reserved - www.nodejitsu.com'.grey,\n  ''\n];\n\n//\n// ### function showWelcome (mode, ipAddress, port)\n// #### @mode {string} The mode that haibu is currently running in.\n// #### @ipAddress {string} The IP Address / host that haibu is binding to.\n// #### @port {int} The port that haibu is binding to.\n// Prints the signature `haibu` welcome message using the colors module.\n//\ncommon.showWelcome = function (role, ipAddress, port) {\n  var plugins = Object.keys(haibu.plugins),\n      serverMsg;\n\n  serverMsg = [\n    'haibu'.yellow.bold,\n    'started @'.grey,\n    (ipAddress || '127.0.0.1').green.bold,\n    'on port'.grey,\n    port.toString().green.bold,\n    'as'.grey,\n    role.green.bold\n  ].join(' ');\n\n  console.log(common.welcome.join('\\n'));\n  console.log(' ' + serverMsg);\n\n  //\n  // If there are any active plugins then\n  // indicate this via logged messages\n  //\n  if (plugins.length > 0) {\n    plugins = plugins.map(function (p) { return p.yellow.bold }).join(', '.grey);\n    console.log('    using plugins: '.grey + plugins);\n  }\n};\n\n//\n// ### function getEndKey (startKey)\n// #### @startKey {string} Startkey paramater for querying CouchDB.\n// Returns the 'endkey' associated with the `startKey`, that is,\n// the same string except with the last character alphabetically incremented.\n//\n// e.g. `char ==> chas`\n//\ncommon.getEndKey = function (startKey) {\n  var length = startKey.length;\n  return startKey.slice(0, length - 1) + String.fromCharCode(startKey.charCodeAt(length - 1) + 1);\n};\n\n//\n// ### function rmApp (appsDir, app, callback)\n// #### @appsDir {string} Root for all application source files.\n// #### @app {App} Application to remove directories for.\n// #### @callback {function} Continuation passed to respond to.\n// Removes all source code associated with the specified `app`.\n//\ncommon.rmApp = function (appsDir, app, callback) {\n  return rimraf(path.join(appsDir, app.user, app.name), callback);\n};\n\n//\n// ### function rmApps (appsDir, callback)\n// #### @appsDir {string} Root for all application source files.\n// #### @callback {function} Continuation passed to respond to.\n// Removes all source code associated with all users and all applications\n// from this Haibu process.\n//\ncommon.rmApps = function (appsDir, callback) {\n  if (!callback && typeof appsDir === 'function') {\n    callback = appsDir;\n    appsDir = null;\n  }\n\n  appsDir = appsDir || haibu.config.get('directories:apps');\n  fs.readdir(appsDir, function (err, users) {\n    if (err) {\n      return callback(err);\n    }\n\n    async.forEach(users, function rmUser (user, next) {\n      rimraf(path.join(appsDir, user), next);\n    }, callback);\n  });\n};\n\n//\n// ### sanitizeAppname (name)\n// Returns sanitized appname (with removed characters) concatenated with\n// original name's hash\n//\ncommon.sanitizeAppname = function (name) {\n  var sha1 = crypto.createHash('sha1');\n\n  sha1.update(name);\n  return name.replace(/[^a-z0-9\\-\\_]+/g, '-') + '-' + sha1.digest('hex');\n};\n\n//\n// ### function ipAddress (name)\n// #### @name {string} **Optional** Name of the network interface\n// Returns the address for the network interface on the current\n// system with the specified `name`. If no interface or `IPv4`\n// family is found return the loopback addres `127.0.0.1`.\n//\ncommon.ipAddress = function (name) {\n  var interfaces = os.networkInterfaces();\n  \n  var addresses = Object.keys(interfaces).map(function (nic) {\n    var addrs = interfaces[nic].filter(function (details) {\n      return details.address !== '127.0.0.1' && details.family === 'IPv4'\n    });\n    return addrs.length ? addrs[0].address : undefined;\n  }).filter(Boolean);\n  \n  return addresses.length\n    ? addresses[0]\n    : '127.0.0.1';\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/common/npm.js":"/*\n * npm.js: Simple utilities for working with npm.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar npm = require('npm'),\n    npmout = npm.log,\n    haibu = require('../../haibu');\n\nvar npmConfig = {\n  _exit: false,\n  exit: false,\n  'unsafe-perm': true,\n  loglevel: \"silent\",\n  production: true\n};\n\n//\n// Monkey patch `npmout.write()` so that we don't need log or out files\n//\nnpmout.write = function () {\n  var args = Array.prototype.slice.call(arguments),\n      message = '',\n      callback;\n\n  args.forEach(function (arg) {\n    if (typeof arg === 'function') {\n      callback = arg;\n    }\n    else {\n      message += arg;\n    }\n  });\n\n  haibu.emit('npm:output', 'info', { info: message });\n \n  if (callback) {\n    callback();\n  }\n};\n\n//\n// ### function load (callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Loads npm with the default `npmConfig`.\n//\nexports.load = function (callback) {\n  haibu.emit('npm:load', 'info', haibu.common.clone(npmConfig));\n  npm.load(npmConfig, function (err) {\n    if (err) {\n      haibu.emit('npm:load', 'error', { error: err.message });\n      return callback(err);\n    }\n\n    haibu.emit('npm:load:success', 'silly');\n    callback();\n  });\n};\n\n//\n// ### function loadDependencies (callback)\n// #### @app {Object} Application to load dependencies for\n// #### @callback {function} Continuation to pass control back to when complete.\n// Loads npm and the dependencies for the target `app`\n//\nexports.loadDependencies = function (app, callback) {\n  var self = this;\n  exports.load(function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (typeof app.dependencies === 'undefined' || Object.keys(app.dependencies).length === 0) {\n      haibu.emit('npm:install:none', 'info', { \n        app: app.name, \n        user: app.user \n      });\n      \n      return callback(null, true, []);\n    }\n\n    var dependencies = Object.keys(app.dependencies);\n    haibu.emit('npm:install:load', 'info', { \n      app: app.name, \n      user: app.user, \n      dependencies: dependencies\n    });\n    \n    callback(null, dependencies);\n  });\n};\n\n//\n// ### function install (dir, target, callback)\n// #### @dir {string} Directory to install targets into.\n// #### @target {Object|Array} Target dependencies or application to install.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Install the `target` dependencies, either an Array of dependencies or a package.json\n// manifest with potential dependencies.\n//\nexports.install = function (dir, target, callback) {\n  if (!dir) {\n    var err = new Error('Cannot install npm dependencies without a target directory.');\n    err.blame = {\n      type: 'system',\n      message: 'NPM configuration'\n    }\n    return callback();\n  }\n\n  var meta = {};\n\n  //\n  // Install all dependencies into the target directory\n  //\n  function installAll(deps) {\n    npm.commands.install(dir, deps, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      haibu.emit('npm:install:success', 'info', meta);\n      callback(null, deps);\n    });\n  }\n\n  //\n  // Loads all dependencies for the `app` manifest and then installs\n  // them into the target directory.\n  //\n  function loadAppAndInstall(app) {\n    exports.loadDependencies(target, function (err, dependencies) {\n      if (err) {\n        return callback(err);\n      }\n      else if (dependencies === true) {\n        return callback(null, []);\n      }\n\n      meta = {\n        app: target.name,\n        dependencies: dependencies\n      };\n\n      haibu.emit('npm:install:start', 'info', meta);\n      installAll(dependencies);\n    });\n  }\n\n  //\n  // Load npm and install the raw list of dependencies\n  //\n  function loadAndInstall() {\n    meta = { packages: target };\n    exports.load(function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      installAll(target);\n    });\n  }\n\n  return Array.isArray(target)\n    ? loadAndInstall()\n    : loadAppAndInstall();\n};\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/core/spawner.js":"/*\n * spawner.js: Spawner object responsible for starting carapace processes.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    forever = require('forever-monitor'),\n    semver = require('semver'),\n    mixin = require('flatiron').common.mixin,\n    haibu = require('../../haibu');\n\nhaibu.getSpawnOptions = function getSpawnOptions (app) {\n  var engine = (app.engines || app.engine || {node: app.engine}).node,\n      engineDir = haibu.config.get('directories:node-installs'),\n      nodeVersions = engineDir && fs.readdirSync(engineDir),\n      carapaceDir = haibu.config.get('directories:carapace-installs'),\n      carapaceVersions = carapaceDir && fs.readdirSync(carapaceDir),\n      env = {}, \n      command = 'node',\n      nodeDir,\n      version,\n      cwd;\n\n  var options = {};\n  if (nodeVersions) {\n    engine = (app.engines || app.engine || {node: app.engine}).node;\n    if (typeof engine !== 'string') {\n      engine = '0.6.x';\n    }\n    version = semver.maxSatisfying(nodeVersions, engine);\n    if (!version) {\n      var err = new Error('Error spawning drone: no matching engine found');\n      err.blame = {\n        type: 'user',\n        message: 'Repository configuration'\n      }\n      throw err;\n    }\n    nodeDir = path.join(engineDir, version);\n  }\n  if (carapaceVersions) {\n    if (typeof engine !== 'string') {\n      engine = '0.4.x';\n    }\n    version = semver.maxSatisfying(carapaceVersions, engine);\n    if (!version) {\n      var err = new Error('Error spawning drone: no matching carapace found');\n      err.blame = {\n        type: 'user',\n        message: 'Repository configuration'\n      }\n      throw err;\n    }\n    options.carapaceBin = path.join(carapaceDir, version, 'node_modules', 'haibu-carapace', 'bin', 'carapace');\n  }\n  else {\n    options.carapaceBin = path.join(require.resolve('haibu-carapace'), '..', '..', 'bin', 'carapace');\n  }\n\n  if (version) {\n    //\n    // Add node (should be configured with --no-npm) and -g modules to path of repo\n    //\n    if (semver.lt(version, '0.6.5')) {\n      options.forkShim = carapaceVersions ? path.join(options.carapaceBin, '..', '..', '..', 'node-fork', 'lib', 'fork.js') : true;\n    }\n    env.NODE_VERSION = 'v'+version;\n    env.NODE_PREFIX = nodeDir;\n    env.NODE_PATH = path.join(nodeDir, 'lib', 'node_modules');\n    env.NODE_CHANNEL_FD = 0;\n    var concatPATH = (process.env.PATH ? ':' + process.env.PATH : '');\n    env.PATH = path.join(nodeDir, 'bin') + ':' + path.join(nodeDir, 'node_modules') + concatPATH;\n    var concatCPATH = (process.env.CPATH ? ':' + process.env.CPATH : '');\n    env.CPATH = path.join(nodeDir, 'include') + ':' + path.join(nodeDir, 'include', 'node') + concatCPATH;\n    var concatLIBRARY_PATH = (process.env.LIBRARY_PATH ? ':' + process.env.LIBRARY_PATH : '');\n    env.LIBRARY_PATH = path.join(nodeDir, 'lib') + ':' + path.join(nodeDir, 'lib', 'node') + concatLIBRARY_PATH;\n    \n    options.cwd = nodeDir;\n    command = path.join(nodeDir, 'bin', 'node');\n  }\n\n  var carapaceEnv = haibu.config.get('carapace:env');\n  if (carapaceEnv) mixin(env, carapaceEnv);\n  if (app.env) mixin(env, app.env);\n  options.env = env;\n  options.command = command;\n  return options;\n}\n\nvar Spawner = exports.Spawner = function Spawner(options) {\n  options = options || {};\n\n  this.maxRestart = options.maxRestart;\n  this.options    = options\n  this.silent     = options.silent     || false;\n  this.host       = options.host       || '127.0.0.1';\n  this.packageDir = options.packageDir || haibu.config.get('directories:packages');\n  this.minUptime  = typeof options.minUptime !== 'undefined' ? options.minUptime : 2000;\n};\n\n//\n// ### function trySpawn (app, callback)\n// #### @app {App} Application to attempt to spawn on this server.\n// #### @callback {function} Continuation passed to respond to.\n// Attempts to spawn the application with the package.json manifest\n// represented by @app, then responds to @callback.\n//\nSpawner.prototype.trySpawn = function (app, callback) {\n  var self = this,\n      repo;\n\n  try { repo = app instanceof haibu.repository.Repository ? app : haibu.repository.create(app) }\n  catch (ex) { return callback(ex) }\n  \n  if (repo instanceof Error) {\n    return callback(repo);\n  }\n\n  repo.bootstrap(function (err, existed) {\n    if (err) {\n      return callback(err);\n    }\n    else if (existed) {\n      return self.spawn(repo, callback);\n    }\n\n    repo.init(function (err, inited) {\n      if (err) {\n        return callback(err);\n      }\n\n      self.spawn(repo, callback);\n    });\n  });\n};\n\n//\n// ### function spawn (app, callback)\n// #### @repo {Repository} App code repository to spawn from on this server.\n// #### @callback {function} Continuation passed to respond to.\n// spawns the appropriate carapace for an Application repository and bootstraps with the events listed\n//\nSpawner.prototype.spawn = function spawn (repo, callback) {\n  if (!(repo instanceof haibu.repository.Repository)) {\n    var err = new Error('Error spawning drone: no repository defined');\n    err.blame = {\n      type: 'user',\n      message: 'Repository configuration'\n    }\n    return callback(err);\n  }\n\n  var self = this,\n      app  = repo.app,\n      meta = { app: app.name, user: app.user },\n      script = repo.startScript,\n      result,\n      responded = false,\n      stderr = [],\n      stdout = [],\n      options = ['--plugin', 'net'],\n      foreverOptions,\n      carapaceBin,\n      timeout,\n      error,\n      drone;\n\n  haibu.emit('spawn:setup', 'info', meta);\n  \n  try {\n    var spawnOptions = haibu.getSpawnOptions(app);\n  }\n  catch (e) {\n    return callback(e);\n  }\n\n  foreverOptions = {\n    fork:      true,\n    silent:    true,\n    stdio:     [ 'ipc', 'pipe', 'pipe' ],\n    cwd:       repo.homeDir,\n    hideEnv:   haibu.config.get('hideEnv'),\n    env:       spawnOptions.env,\n    killTree:  true,\n    killTTL:   0,\n    minUptime: this.minUptime,\n    command:   spawnOptions.command,\n    options:   [spawnOptions.carapaceBin].concat(options)\n  };\n\n  //\n  // Concatenate the `argv` of any plugins onto the options\n  // to be passed to the carapace script.\n  //\n  Object.keys(haibu.plugins).forEach(function (plugin) {\n    var spawn;\n\n    if (haibu.plugins[plugin].argv) {\n      haibu.emit('plugin:argv', 'info', {\n        app: app.name,\n        user: app.user,\n        plugin: plugin\n      });\n\n      spawn = haibu.plugins[plugin].argv(repo);\n\n      if (spawn.script) {\n        script = spawn.script\n      }\n\n      if (spawn.argv) {\n        foreverOptions.options = foreverOptions.options.concat(spawn.argv);\n      }\n    }\n  });\n\n  foreverOptions.forever = typeof self.maxRestart === 'undefined';\n  if (typeof self.maxRestart !== 'undefined') {\n    foreverOptions.max = self.maxRestart;\n  }\n\n  //\n  // Before we attempt to spawn, let's check if the startPath actually points to a file\n  // Trapping this specific error is useful as the error indicates an incorrect\n  // scripts.start property in the package.json\n  //\n  fs.stat(repo.startScript, function (err, stats) {\n    if (err) {\n      var err = new Error('package.json error: ' + 'can\\'t find starting script: ' + repo.app.scripts.start);\n      err.blame = {\n        type: 'user',\n        message: 'Package.json start script declared but not found'\n      }\n      return callback(err);\n    }\n\n    foreverOptions.options.push(script);\n    carapaceBin = foreverOptions.options.shift();    \n    drone = new forever.Monitor(carapaceBin, foreverOptions);\n    drone.on('error', function () {\n      //\n      // 'error' event needs to be caught, otherwise\n      // the haibu process will die\n      //\n    });\n\n    haibu.emit(['spawn', 'begin'], 'info', {\n      options: foreverOptions.options.join(' '),\n      app: meta.app,\n      user: meta.user,\n      drone: drone,\n      pkg: app\n    });\n\n    //\n    // Log data from `drone.stdout` to haibu\n    //\n    function onStdout (data) {\n      data = data.toString();\n      haibu.emit('drone:stdout', 'info', data, meta);\n\n      if (!responded) {\n        stdout = stdout.concat(data.split('\\n').filter(function (line) { return line.length > 0 }));\n      }\n    }\n\n    //\n    // Log data from `drone.stderr` to haibu\n    //\n    function onStderr (data) {\n      data = data.toString();\n      haibu.emit('drone:stderr', 'error', data, meta);\n\n      if (!responded) {\n        stderr = stderr.concat(data.split('\\n').filter(function (line) { return line.length > 0 }));\n      }\n    }\n\n    //\n    // If the `forever.Monitor` instance emits an error then\n    // pass this error back up to the callback.\n    //\n    // (remark) this may not work if haibu starts two apps at the same time\n    //\n    function onError (err) {\n      if (!responded) {\n        errState = true;\n        responded = true;\n        callback(err);\n\n        //\n        // Remove listeners to related events.\n        //\n        drone.removeListener('exit', onExit);\n        drone.removeListener('message', onCarapacePort);\n        clearTimeout(timeout);\n      }\n    }\n\n    //\n    // When the carapace provides the port that the drone\n    // has bound to then respond to the callback\n    //\n    function onCarapacePort (info) {\n      if (!responded && info && info.event === 'port') {\n        responded = true;\n        result.socket = {\n          host: self.host,\n          port: info.data.port\n        };\n        \n        drone.minUptime = 0;\n\n        haibu.emit('drone:port', 'info', {\n          pkg: app,\n          info: info\n        });\n        \n        callback(null, result);\n        \n        //\n        // Remove listeners to related events\n        //\n        drone.removeListener('exit', onExit);\n        drone.removeListener('error', onError);\n        clearTimeout(timeout);\n      }\n    }\n\n    //\n    // When the drone starts, update the result for monitoring software\n    //\n    function onChildStart (monitor, data) {\n      result = {\n        monitor: monitor,\n        process: monitor.child,\n        data: data,\n        pid: monitor.childData.pid,\n        pkg: app\n      };\n\n      haibu.emit(['drone', 'start'], 'info', {\n        process: data,\n        pkg: result.pkg\n      });\n    }\n\n    //\n    // When the drone stops, update the result for monitoring software\n    //\n    function onChildRestart (monitor, data) {\n      haibu.emit(['drone', 'stop'], 'info', {\n        process: result.data,\n        pkg: result.pkg\n      });\n      \n      haibu.emit(['drone', 'start'], 'info', {\n        process: data,\n        pkg: result.pkg\n      });\n    }\n\n    //\n    // If the drone exits prematurely then respond with an error\n    // containing the data we receieved from `stderr`\n    //\n    function onExit () {\n      if (!responded) {\n        errState = true;\n        responded = true;\n        error = new Error('Error spawning drone');\n        error.blame = {\n          type: 'user',\n          message: 'Script prematurely exited'\n        }\n        error.stdout = stdout.join('\\n');\n        error.stderr = stderr.join('\\n');\n        callback(error);\n\n        //\n        // Remove listeners to related events.\n        //\n        drone.removeListener('error', onError);\n        drone.removeListener('message', onCarapacePort);\n        clearTimeout(timeout);\n      }\n    }\n\n    function onTimeout() {\n      drone.removeListener('exit', onExit);\n\n      drone.stop();\n      error = new Error('Error spawning drone');\n      error.blame = {\n        type: 'user',\n        message: 'Script took too long to listen on a socket'\n      };\n      error.stdout = stdout.join('\\n');\n      error.stderr = stderr.join('\\n');\n\n      callback(error);\n    }\n\n    //\n    // Listen to the appropriate events and start the drone process.\n    //\n    drone.on('stdout', onStdout);\n    drone.on('stderr', onStderr);\n    drone.once('exit', onExit);\n    drone.once('error', onError);\n    drone.once('start', onChildStart);\n    drone.on('restart', onChildRestart);\n    drone.on('message', onCarapacePort);\n\n    timeout = setTimeout(onTimeout, haibu.config.get('portTimeout') || 20000);\n\n    drone.start();\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/index.js":"/*\n * index.js: Top-level include for the repository module.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar haibu = require('../../haibu');\n\n//\n// ### Export Components\n// Export relevant components of the repositories module\n//\nexports.Repository = require('./repository').Repository;\n\n// Fill repos store with known repository types\nvar repos = {\n  git:   require('./git').Git,\n  local: require('./local-file').LocalFile,\n  npm:   require('./npm').Npm,\n  tar:   require('./tar').Tar,\n  zip:   require('./zip').Zip\n};\n\n//\n// ### function create (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Creates a repository for the specified application by switching\n// off `app.repository.type' in the application package.json manifest.\n//\nexports.create = function (app, options) {\n  //\n  // Perform validation on app before we attempt to create a repository\n  //\n  exports.validate(app);\n\n  var type = typeof app.repository.type === 'string' ? app.repository.type.toLowerCase() : '';\n\n  if (type === '' || !repos[type]) {\n    var err = new Error('Cannot create repository for unknown type ' + type);\n    err.blame = {\n      type: 'user',\n      message: 'Repository configuration specified unknown type of repository'\n    }\n    throw err;\n  }\n\n  haibu.emit('repository:create', 'info', {\n    type: type,\n    app: app.name,\n    user: app.user\n  });\n\n  return new (repos[type])(app, options);\n};\n\n//\n// ### function add (name, class)\n// #### @name {String} Name of the repository to add\n// #### @constructor {Function} Constructor of the repository instance to create\n// Adds a new repository constructor to the repository list\n//\nexports.add = function (name, constructor) {\n  if (repos[name]) {\n    var err = new Error('A repository type with this name (' + name + ') already exists!');\n    err.blame = {\n      type: 'user',\n      message: 'Repository already exists'\n    }\n    throw err;\n  }\n\n  repos[name] = constructor;\n};\n\n//\n// ### function remove (name)\n// #### @name {String} Name of the repository to remove\n// Removes a repository constructor from the repository list\n//\nexports.remove = function (name) {\n  if (!repos[name]) {\n    var err = new Error('A repository type with this name (' + name + ') does not exists!');\n    err.blame = {\n      type: 'user',\n      message: 'Repository already exists'\n    }\n    throw err;\n  }\n\n  delete repos[name];\n};\n\n//\n// ### function list ()\n// Lists all repository types names in the repository list. Returns array of names.\n//\nexports.list = function () {\n  return Object.keys(repos);\n};\n\n//\n// ### function validate (pkg)\n// #### @pkg {Object} The package.json manifest to validate\n// Validates the package.json manifest for the basic haibu usage.\n//\nexports.validate = function (pkg) {\n  return exports.Repository.prototype.validate([], pkg);\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/repository.js":"/*\n * repository.js: Base implementation of the repository pattern.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    haibu = require('../../haibu');\n\n//\n// ### function Repository (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Constructor function for the Repository base object. This contains\n// the core implementations used by inherited prototypes in the\n// `repositories` module.\n//\nvar Repository = exports.Repository = function (app, options) {\n  options = options || {};\n\n  //\n  // checks all properties of this.app recursively through\n  // all child classes of Repository\n  //\n  this.validate([], app);\n\n  this.app = app;\n  this.app._id = app.name.replace(' ', '-');\n  this.appsDir = options.appsDir || haibu.config.get('directories:apps');\n};\n\n//\n// ### function validate ()\n// #### @keys {Array||String} The keys to check in app. (i.e. 'scripts.start')\n// #### @app {Object} (optional) The app object to check. if not given this.app will be used.\n// #### @return {Error|| undefined} undefined if valid, Error if not\n// Checks Application configuration attributes used by this repository type\n//\nRepository.prototype.validate = function (keys, app) {\n  var i, i2, required, props, check;\n\n  // Check for the basic required properties needed for haibu repositories + requested ones\n  keys = keys || [];\n  required = ['name', 'user', 'repository.type', 'scripts.start'].concat(keys);\n\n  for (i = 0; i < required.length; i++) {\n    // split property if needed and run over each part\n    props = required[i].split('.');\n    check = app || this.app;\n\n    for (i2 = 0; i2 < props.length; i2++) {\n      if (typeof(check[props[i2]]) == 'undefined') {\n        var message = ['Property', required[i], 'is required.'].join(' ');\n        haibu.emit('repo:validate', 'warn',  message, check);\n        var err = new Error(message);\n        err.blame = {\n          type: 'user',\n          message: 'Missing properties in repository configuration'\n        }\n        throw err;\n        return;\n      }\n\n      check = check[props[i2]];\n    }\n  }\n  // all ok!\n  return;\n}\n\n//\n// ### function installDependencies (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Installs the required npm dependencies for the app associated\n// with this repository instance on this system.\n//\nRepository.prototype.installDependencies = function (callback) {\n  var self = this;\n\n  fs.readFile(path.join(this.homeDir, 'package.json'), function (err, data) {\n    if (!err) {\n      try {\n        pkg = JSON.parse(data);\n        pkg.dependencies = pkg.dependencies || {};\n        self.app.dependencies = haibu.common.mixin({}, pkg.dependencies, self.app.dependencies || {});\n      }\n      catch (err) {\n        //\n        // Ignore errors\n        //\n      }\n    }\n\n    haibu.common.npm.install(self.homeDir, self.app, callback)\n  });\n};\n\n//\n// ### function stat (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Check if there is only one directory in the appDir path\n//\nRepository.prototype.stat = function (callback) {\n  var self = this;\n\n  //\n  // Assume that there is ONLY one directory allowed in each application directory.\n  // ex:\n  //   /local\n  //   /local/:username\n  //   /local/:username/:appname\n  //   /local/:username/:appname/:home\n  //\n  // By making this assumption we can infer the home directory immediately at run-time for\n  // all possible package.json repository types and remotes.\n  //\n  fs.readdir(this.appDir, function (err, files) {\n    if (err) {\n      // Since we couldn't find the directory we need to pass it to addDir\n      haibu.emit('repo:dir:notfound', 'warn', { \n        app: self.app.name, \n        dir: self.appDir,\n        user: self.app.user\n      });\n      \n      err.blame = {\n        type: 'system',\n        message: 'Cannot find application directories'\n      }\n      \n      return callback(err, false);\n    }\n    else if (files.length === 0) {\n      haibu.emit('repo:dir:empty', 'warn', { \n        app: self.app.name, \n        user: self.app.user,\n        dir: self.appDir\n      });\n      \n      err = new Error('Application directory is empty');\n      err.blame = {\n        type: 'user',\n        message: 'Repository local directory empty'\n      }\n      \n      return callback(err);\n    }\n\n    // Now that we know the home directory, set it on the app managed by this repository\n    var firstNonDot = files.filter(function (f) { return f[0] !== '.' })[0],\n        sourceDir = path.join(self.appDir, firstNonDot);\n    \n    self._setHome(firstNonDot);\n\n    haibu.emit('repo:dir:exists', 'info', { \n      app: self.app.name, \n      user: self.app.user,\n      dir: sourceDir \n    });\n    \n    callback(null, true);\n  });\n};\n\n//\n// ### function mkdir (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Creates directories for the applications and userspaces for the app\n// associated with this repository instance.\n//\nRepository.prototype.mkdir = function (callback) {\n  var self = this;\n  haibu.emit('repo:dir:user:create', 'info', { \n    app: self.app.name, \n    user: self.app.user,\n    dir: this.userDir \n  });\n\n  // check if the user's folder already exists\n  fs.stat(self.userDir, function (userErr, stats) {\n    function createAppDir() {\n      haibu.emit('repo:dir:app:create', 'info', { \n        app: self.app.name, \n        user: self.app.user,\n        dir: self.appDir\n      });\n\n      // check if the application's folder already exists\n      fs.stat(self.appDir, function (droneErr, stats) {\n        if (droneErr) { // folder doesn't exist\n          return fs.mkdir(self.appDir, 0755, function (mkAppErr) {\n            if (mkAppErr) {\n              haibu.emit('repo:dir:app:create', 'error', { \n                app: self.app.name, \n                user: self.app.user,\n                dir: self.appDir\n              });\n              \n              return callback(mkAppErr, false);\n            }\n\n            // If we created the directory successfully callback with true\n            haibu.emit('repo:dir:app:success', 'info', { \n              app: self.app.name, \n              user: self.app.user,\n              dir: self.appDir\n            });\n            \n            callback(null, true);\n          });\n        }\n\n        callback(null, true);\n      });\n    }\n\n    if (userErr) {\n      return fs.mkdir(self.userDir, 0755, function (mkUserErr) {\n        if (mkUserErr) {\n          haibu.emit('repo:dir:user:create', 'error', { \n            app: self.app.name, \n            user: self.app.user,\n            dir: self.userDir\n          });\n          \n          return callback(mkUserErr, false);\n        }\n\n        haibu.emit('repo:dir:user:success', 'info', { \n          app: self.app.name, \n          user: self.app.user,\n          dir: self.userDir\n        });\n        \n        createAppDir();\n      });\n    }\n\n    createAppDir();\n  });\n};\n\n//\n// ### function bootstrap (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Bootstraps the files on the local system for this instance.\n// If the files already exist, it simply responds.\n//\nRepository.prototype.bootstrap = function (callback) {\n  var self = this;\n  this.stat(function (err, exists) {\n    if (err) {\n      return self.mkdir(function (err, created) {\n        callback(null, false);\n      });\n    }\n\n    // If it already exists assume mkdir and init have also been called\n    callback(null, true);\n  });\n};\n\n//\n// ### @userDir {string}\n// Location on disk of all the apps for the user who this\n// repository instance manages\n//\nRepository.prototype.__defineGetter__('userDir', function () {\n  return path.join(this.appsDir, this.app.user);\n});\n\n//\n// ### @appDir {string}\n// Location on disk of the app for the user who this\n// repository instance manages.\n//\nRepository.prototype.__defineGetter__('appDir', function () {\n  return path.join(this.userDir, this.app.name);\n});\n\n//\n// ### @homeDir {string}\n// Location on disk of the home directory for the app\n// that this repository instance manages.\n//\nRepository.prototype.__defineGetter__('homeDir', function () {\n  if (!this.app.directories || typeof this.app.directories.home == 'undefined') {\n    return null;\n  }\n\n  return path.join(this.appDir, this.app.directories.home);\n});\n\n//\n// ### @startScript {string}\n// Location on disk of all the start script for the app\n// that this repository instance manages\n//\nRepository.prototype.__defineGetter__('startScript', function () {\n  if (!this.homeDir) {\n    return null;\n  }\n  var allowedExecutables = haibu.config.get('allowedExecutables'),\n    script = this.app.scripts.start,\n    executable = script.split(/\\s+/, 1)[0],\n    replaced = false;\n  if (allowedExecutables) {\n    for(var i = 0; i < allowedExecutables.length; i++) {\n      if (executable === allowedExecutables[i]) {\n        this.executable = executable;\n        script = script.substr(executable.length).trim();\n        break;\n      }\n    }\n  }\n  return path.join(this.homeDir, script); \n});\n\n//\n// ### @private function _setHome (path)\n// @path {string} The home directory to set for this instance\n// Sets the home directory for this instance to the specified path.\n//\nRepository.prototype._setHome = function (path) {\n  this.app.directories = this.app.directories || {};\n  this.app.directories.home = path;\n};\n\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/git.js":"/*\n * git.js: Implementation of the repository pattern for remote git repositories.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    path = require('path'),\n    exec = require('child_process').exec,\n    haibu = require('../../haibu'),\n    Repository = require('./repository').Repository;\n\n//\n// ### function Git (app, options)\n// #### @app {App} Application manifest to wrap\n// #### @options {Object} Options for this instance\n// Constructor function for the Git repository object. Responsible\n// for cloning, and updating Git repositories.\n//\nvar Git = exports.Git = function (app, options) {\n  return Repository.call(this, app, options);\n};\n\n// Inherit from Repository\nutil.inherits(Git, Repository);\n\n//\n// ### function validate ()\n// #### @keys {Array||String} The keys to check in app. (i.e. 'scripts.start')\n// #### @app {Object} (optional) The app object to check. if not given this.app will be used.\n// #### @return {Error|| undefined} undefined if valid, Error if not\n// Checks Application configuration attributes used by this repository type\n//\nGit.prototype.validate = function (keys, app) {\n  keys = keys || [];\n  return Repository.prototype.validate.call(this, keys.concat('repository.url'), app);\n}\n\n//\n// ### function init (callback)\n// #### @callback {function} Continuation to respond to.\n// Initializes the git repository associated with the application\n// and this instance. Checks out the specific branch in `app.repository.branch`\n// if it exists. Initializes and updates git submodules. Initializes npm dependencies\n// through calling `self.installDependencies`.\n//\nGit.prototype.init = function (callback) {\n  var self = this;\n\n  function installNpm () {\n    self.installDependencies(function (err, packages) {\n      return err ? callback(err) : callback(null, true, packages);\n    });\n  }\n\n  haibu.emit('git:clone', 'info', {\n    type: 'git',\n    user: self.app.user,\n    name: self.app.name,\n    from: self.app.repository.url,\n    to: self.appDir\n  });\n\n  // TODO (indexzero): Validate the security of this regular expression since it is on the command line.\n  var commands, match = self.app.repository.url.match(/\\/([\\w\\-_\\.]+)\\.git$/);\n  if (!match) {\n    var err = new Error('Invalid git url: ' + self.app.repository.url);\n    err.blame = {\n      type: 'user',\n      message: 'Repository configuration present but provides invalid Git URL'\n    };\n    return callback(err);\n  }\n\n  // Set the home directory of the app managed by this instance.\n  self._setHome(match[1]);\n\n  // Setup the git commands to be executed\n  commands = [\n    'cd ' + self.appDir + ' && git clone ' + self.app.repository.url,\n    'cd ' + path.join(self.appDir, match[1])\n  ];\n\n  if (self.app.repository.branch) {\n    commands[1] += ' && git checkout ' + self.app.repository.branch;\n  }\n\n  commands[1] += ' && git submodule update --init --recursive';\n\n  function executeUntilEmpty() {\n    var command = commands.shift();\n\n    // Remark: Using 'exec' here because chaining 'spawn' is not effective here\n    exec(command, function (err, stdout, stderr) {\n      if (err !== null) {\n        haibu.emit('git:clone', 'error', {\n          url: self.app.repository.url,\n          dir: self.appDir,\n          app: self.app.name,\n          error: err.message,\n          command: command,\n          type: 'git',\n          user: self.app.user\n        });\n\n        callback(err, false);\n      }\n      else if (commands.length > 0) {\n        executeUntilEmpty();\n      }\n      else if (commands.length === 0) {\n        installNpm();\n      }\n    });\n  }\n\n  executeUntilEmpty();\n};\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/local-file.js":"/*\n * local-file.js: Base implementation of the repository pattern for remote files.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    exec = require('child_process').exec,\n    haibu = require('../../haibu'),\n    Repository = require('./repository').Repository;\n\n//\n// ### function LocalFile (app, options)\n// #### @app {App} Application manifest to wrap\n// #### @options {Object} Options for this instance\n// Constructor function for the LocalFile Repository responsible for\n// loading applications from a location on the local filesystem.\n//\nvar LocalFile = exports.LocalFile = function (app, options) {\n  var invalid = Repository.call(this, app, options);\n  if (invalid) return invalid;\n\n  options = options || {};\n  this.packageDir = options.packageDir || haibu.config.get('directories:packages');\n};\n\n// Inherit from Repository\nutil.inherits(LocalFile, Repository);\n\n//\n// ### function validate ()\n// #### @keys {Array||String} The keys to check in app. (i.e. 'scripts.start')\n// #### @app {Object} (optional) The app object to check. if not given this.app will be used.\n// #### @return {Error|| undefined} undefined if valid, Error if not\n// Checks Application configuration attributes used by this repository type\n//\nLocalFile.prototype.validate = function (keys, app) {\n  keys = keys || [];\n  return Repository.prototype.validate.call(this, keys.concat('repository.directory'), app);\n}\n\n//\n// ### function fetch (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Checks to see if the app repo directorie exist.\n//\nLocalFile.prototype.fetch = function (callback) {\n  var self = this,\n      repoDir = this.app.repository.directory;\n\n  fs.stat(repoDir, function (err) {\n    callback(err, repoDir);\n  });\n};\n\n//\n// ### function init (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Initializes this instance by checking the app, then copying the files located in\n// `app.repository.directory` to the target directory set on `this.appDir`, then\n// installing npm dependencies.\n//\nLocalFile.prototype.init = function (callback) {\n  var self = this;\n\n  haibu.emit('local:clone', 'info', {\n    type: 'local',\n    user: self.app.user,\n    name: self.app.name,\n    from: self.app.repository.directory,\n    to: self.appDir\n  });\n\n  this.fetch(function (err, localDirectory) {\n    if (err) {\n      return callback(err);\n    }\n\n    exec('cp -r ' + localDirectory + ' ' + self.appDir, function (err) {\n      self.stat(function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        self.installDependencies(function (err, packages) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, true, packages);\n        });\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/npm.js":"/*\n * npm.js: Implementation of the repository pattern for npm packages.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    fs = require('fs'),\n    haibu = require('../../haibu'),\n    Repository = require('./repository').Repository;\n\n//\n// ### function Npm (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Constructor function for the Npm repository.\n//\nvar Npm = exports.Npm = function (app, options) {\n  return Repository.call(this, app, options);\n};\n\n// Inherit from Repository.\nutil.inherits(Npm, Repository);\n\n//\n// ### function validate ()\n// #### @keys {Array||String} The keys to check in app. (i.e. 'scripts.start')\n// #### @app {Object} (optional) The app object to check. if not given this.app will be used.\n// #### @return {Error|| undefined} undefined if valid, Error if not\n// Checks Application configuration attributes used by this repository type\n//\nNpm.prototype.validate = function (keys, app) {\n  keys = keys || [];\n  return Repository.prototype.validate.call(this, keys.concat('repository.package'), app);\n}\n\n//\n// ### function init (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Installs the given `app.repository.package` with NPM to the appDir directory.\n// REMARK: the application will be installed in this.homeDir + app.repository.package\n// If the package has bin scripts they are installed by NPM in this.homeDir + '.bin'\n//\nNpm.prototype.init = function (callback) {\n  var self = this;\n  // fetch app from npm repository + install dependencies\n  haibu.common.npm.install(this.appDir, [this.app.repository.package], function (err, dependencies) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.stat(function (err, exists) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, true, dependencies);\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/tar.js":"/*\n * Tar.js: Implementation of the repository pattern for remote tar files.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    util = require('util'),\n    haibu = require('../../haibu'),\n    RemoteFile = require('./remote-file').RemoteFile;\n\n//\n// ### function Tar (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Constructor function for the Tar repository.\n//\nvar Tar = exports.Tar = function (app, options) {\n  return RemoteFile.call(this, app, options);\n};\n\n// Inherit from the RemoteFile repository\nutil.inherits(Tar, RemoteFile);\n\n//\n// ### function init (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Initializes this instance by checking the app, then installing\n// npm dependencies, then downloading files located in repository\n// to the target directory set on `this.appDir`\n//\nTar.prototype.init = function (callback) {\n  var self = this;\n\n  haibu.emit('tar:get', 'info', {\n    type: 'tar',\n    user: self.app.user,\n    name: self.app.name,\n    protocol: self.app.repository.protocol,\n    from: self.app.repository.url,\n    to: self.appDir\n  });\n\n  this.fetch(function (err, packageFile) {\n    if (err) {\n      return callback(err);\n    }\n\n    var child = require('child_process').spawn('tar', ['-C', self.appDir, '-xzf', '-']),\n        files = [];\n\n    fs.createReadStream(packageFile).pipe(child.stdin);\n\n    child.on('exit', function (statusCode) {\n      if (statusCode) {\n        return callback(new Error('tar exited with code: ' + statusCode));\n      }\n\n      self.stat(function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        self.installDependencies(function (err, packages) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, true, packages, files);\n        });\n      });\n    });\n  });\n};\n\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/remote-file.js":"/*\n * remote-file.js: Base implementation of the repository pattern for remote files.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    fs = require('fs'),\n    path = require('path'),\n    url = require('url'),\n    request = require('request'),\n    cloudfiles = require('cloudfiles'),\n    haibu = require('../../haibu'),\n    knox = require('knox'),\n    Repository = require('./repository').Repository;\n\n//\n// ### function RemoteFile (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Constructor function for the RemoteFile repository responsible for\n// downloading files from remote locations.\n//\n// Currently supported remotes are:\n// * HTTP / HTTPS\n// * Cloudfiles\n//\nvar RemoteFile = exports.RemoteFile = function (app, options) {\n  var invalid = Repository.call(this, app, options);\n  if (invalid) {\n    return invalid;\n  }\n\n  options = options || {};\n  this.packageDir = options.packageDir || haibu.config.get('directories:packages');\n};\n\n// Inherit from Repository\nutil.inherits(RemoteFile, Repository);\n\n//\n// ### function validate ()\n// #### @keys {Array||String} The keys to check in app. (i.e. 'scripts.start')\n// #### @app {Object} (optional) The app object to check. if not given this.app will be used.\n// #### @return {Error|| undefined} undefined if valid, Error if not\n// Checks Application configuration attributes used by this repository type\n//\nRemoteFile.prototype.validate = function (keys, app) {\n  keys = keys || [];\n\n  var test = app && app.repository && app.repository.protocol === 'cloudfiles'\n       ? ['repository.auth', 'repository.container', 'repository.filename']\n       : ['repository.url'];\n\n  return Repository.prototype.validate.call(this, keys.concat('repository.protocol', test), app);\n};\n\n//\n// ### function fetch (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Fetches the file(s) associated with the repository from the remote location\n// based on `app.repository.protocol`.\n//\nRemoteFile.prototype.fetch = function (callback) {\n  var protocol = this.app.repository.protocol, options;\n\n  if (protocol === 'http' || protocol === 'https') {\n    this.fetchHttp(this.app.repository.url, callback);\n  }\n  else if (protocol === 'cloudfiles') {\n    options = {\n      container: this.app.repository.container,\n      filename: this.app.repository.filename\n    };\n\n    this.fetchCloudfiles(options, callback);\n  }\n  else if (protocol === 's3') {\n    this.fetchS3(this.app.repository.url, callback);\n  }\n  else {\n    var err = new Error('Cannot fetch app with unknown protocol: ' + this.app.repository.protocol);\n    err.blame = {\n      type: 'user',\n      message: 'Unknown protocol to fetch the repository from'\n    }\n    callback(err);\n  }\n};\n\n//\n// ### function fetchCloudfiles (options, callback)\n// #### @options {Object} Options for the Cloudfiles remote\n// #### @callback {function} Continuation to pass control back to when complete.\n// Fetches the file specified by `options.filename` from the Rackspace Cloudfiles\n// container specified by `options.container` then saves it to the local packages cache.\n//\nRemoteFile.prototype.fetchCloudfiles = function (options, callback) {\n  var self = this;\n\n  this.client = cloudfiles.createClient({ auth: this.app.repository.auth });\n\n  // Configure cloudfiles to make it's local cache directory\n  // the same as haibu's packages directory\n  this.client.config.cache.path = this.packageDir;\n\n  this.client.setAuth(function () {\n    self.client.getFile(options.container, options.filename, function (err, file) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, path.join(self.client.config.cache.path, options.container, options.filename));\n    });\n  });\n};\n\n//\n// ### function fetchCloudfiles (options, callback)\n// #### @options {Object} Options for the Cloudfiles remote\n// #### @callback {function} Continuation to pass control back to when complete.\n// Fetches the file specified by `options.filename` from the Rackspace Cloudfiles\n// container specified by `options.container` then saves it to the local packages cache.\n//\nRemoteFile.prototype.fetchS3 = function (filename, callback) {\n  var self = this,\n      localFile = path.join(this.packageDir, filename),\n      localStream = fs.createWriteStream(localFile),\n      done = false,\n      client = knox.createClient(this.app.repository.auth);\n\n  client.get(filename).on('response', function (res) {\n    if (done) return;\n    done = true;\n    localStream.once('close', function () {\n      callback(null, localFile);\n    });\n    res.pipe(localStream);\n  }).on('error', function (e) {\n    if (done) return;\n    done = true;\n    localStream.end();\n    callback(e);\n  }).end();\n};\n\n//\n// ### function fetchHttp (remotePath, callback)\n// #### @remotePath {string} Location of the remote HTTP/HTTPS file\n// #### @callback {function} Continuation to pass control back to when complete.\n// Fetches the file specified by `remotePath` then saves it to the local packages cache.\n//\nRemoteFile.prototype.fetchHttp = function (remotePath, callback) {\n  var self = this, out,\n      filename = url.parse(remotePath).pathname.split('/').pop(),\n      localFile = path.join(this.packageDir, filename),\n      localStream = fs.createWriteStream(localFile);\n\n  out = request({ uri: remotePath });\n  out.pipe(localStream);\n  localStream.once('close', function () {\n    callback(null, localFile);\n  });\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/repositories/zip.js":"/*\n * zip.js: Implementation of the repository pattern for remote zip files.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    exec = require('child_process').exec,\n    haibu = require('../../haibu'),\n    RemoteFile = require('./remote-file').RemoteFile;\n\n//\n// ### function Zip (app, options)\n// #### @app {Object} The application to create the repository for\n// #### @options {Object} Options to pass along to the repository\n// Constructor function for the Zip repository.\n//\nvar Zip = exports.Zip = function (app, options) {\n  return RemoteFile.call(this, app, options);\n};\n\n// Inherit from the RemoteFile repository\nutil.inherits(Zip, RemoteFile);\n\n//\n// ### function init (callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Initializes this instance by checking the app, then installing\n// npm dependencies, then downloading files located in repository\n// to the target directory set on `this.appDir`\n//\nZip.prototype.init = function (callback) {\n  var self = this;\n\n  haibu.emit('tar:get', 'info', {\n    type: 'tar',\n    user: self.app.user,\n    name: self.app.name,\n    protocol: self.app.repository.protocol,\n    from: self.app.repository.url,\n    to: self.appDir\n  });\n\n  this.fetch(function (err, packageFile) {\n    if (err) {\n      return callback(err);\n    }\n\n    var command = 'unzip -u ' + packageFile + ' -d ' + self.appDir;\n    exec(command, function (err, stdout, stderr) {\n      self.stat(function (err, exists) {\n        if (err) {\n          return callback(err);\n        }\n\n        self.installDependencies(function (err, packages) {\n          if (err) {\n            return callback(err);\n          }\n\n          var files = stdout.split('\\n').splice(1).map(function (line) {\n            return line.slice(13);\n          });\n\n          callback(null, true, packages, files);\n        });\n      });\n    });\n  });\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/drone/index.js":"/*\n * index.js: Top-level include for the drone module.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar fs = require('fs'),\n    path = require('path'),\n    http = require('http'),\n    flatiron = require('flatiron'),\n    haibu = require('../../haibu'),\n    async = haibu.common.async;\n\n//\n// ### Include Exports\n// Export other components in the module\n//\nexports.Drone   = require('./drone').Drone;\nexports.Client  = require('haibu-api').Client;\nexports.started = false;\n\n//\n// ### function autostart (server, callback)\n// #### @server {http.Server} Haibu drone server to autostart drones with.\n// #### @callback {function} Continuation to respond to when complete\n// Autostarts drones for all applications persisted to\n// `haibu.config.get('directories:autostart')`.\n//\nexports.autostart = function (server, callback) {\n  var autostartDir = haibu.config.get('directories:autostart');\n  \n  //\n  // Helper function which starts multiple drones\n  // a given application.\n  //\n  function startDrones (pkg, done) {\n    if (pkg.drones == 0) {\n      return done();\n    }\n\n    var started = 0;\n\n    async.whilst(function () {\n      return started < pkg.drones;\n    }, function (next) {\n      started++;\n      server.drone.start(pkg, next);\n    }, done);\n  }\n\n  //\n  // Find all drones in directory:\n  //   %dir/%sanitized_name.json\n  //\n  fs.readdir(autostartDir, function (err, files) {\n    if (err) {\n      return callback(err);\n    }\n\n    async.map(files, function (file, next) {\n      //\n      // Read each `package.json` manifest file and start\n      // the appropriate drones in this `haibu` instance.\n      //\n      fs.readFile(path.join(autostartDir, file), function (err, pkg) {\n        if (err) {\n          return callback(err);\n        }\n\n        //\n        // Read the contents of the package.json manifest,\n        // which should be JSON\n        //\n        try {\n          pkg = JSON.parse(pkg.toString());\n        }\n        catch (ex) {\n          return callback(ex);\n        }\n\n        startDrones(pkg, next);\n      });\n    }, callback);\n  });\n}\n\n//\n// ### function start (options, callback)\n// #### @options {Object} Options to use when starting this module.\n// #### @callback {function} Continuation to respond to when complete.\n// Starts the haibu `drone` webservice with the specified options.\n//\nexports.start = function (options, callback) {\n  if (exports.started) {\n    return callback(null, haibu.running.server);\n  }\n\n  function tryAutostart (server) {\n    exports.autostart(server, function (err) {\n      //\n      // Ignore errors from autostart and continue\n      // bringing up the haibu `drone` server.\n      //\n      // Remark: We should report the `err` somewhere\n      //\n      haibu.emit('start');\n      callback(null, server);\n    });\n  }\n\n  function startServer (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    //\n    // Create the server and add the new `http.Server`\n    // and `haibu.drone.Drone` instance into the `haibu.running`\n    // namespace.\n    //\n    var drone = new haibu.drone.Drone(options);\n\n    //\n    // Setup the `union` server through `flatiron.plugins.http`\n    // and then add routes.\n    //\n    haibu.use(flatiron.plugins.http, options.http || {});\n    require('./service').createRouter(drone);\n\n    if (options.port) {\n      haibu.listen(options.port);\n    }\n\n    haibu.running.server = haibu.server;\n    haibu.running.drone  = haibu.server.drone = drone;\n    haibu.running.ports  = {};\n\n    //\n    // There is a current bug in node that throws here:\n    //\n    // https://github.com/joyent/node/blob/v0.4.12/lib/net.js#L159\n    //\n    // It will throw a broken pipe error (EPIPE) when a child process that you \n    // are piping to unexpectedly exits. The write function on line 159 is \n    // defined here:\n    //\n    // https://github.com/joyent/node/blob/v0.4.12/lib/net.js#L62\n    //\n    // This uncaughtExceptionHandler will catch that error,\n    // and since it originated with in another sync context,\n    // this section will still respond to the request.\n    //\n    haibu.plugins.exceptions.logger.exitOnError = function (err) {\n      if (err.code === 'EPIPE') {\n        console.log('expected error:');\n        console.log('EPIPE -- probabaly caused by someone pushing a non gzip file.');\n        console.log('\"net\" throws on a broken pipe, current node bug, not haibu.');\n        return false;\n      }\n\n      return true;\n    };\n\n    //\n    // Attempt to autostart any applications and respond.\n    //\n    tryAutostart(haibu.server);\n  }\n\n  //\n  // Indicate that `haibu.drone` has started\n  //\n  exports.started = true;\n  \n  return haibu.initialized\n    ? startServer()\n    : haibu.init(options, startServer);\n};\n\n//\n// ### function stop (callback)\n// #### @cleanup {bool} (optional) Remove all autostart files (default=true).\n// #### @callback {function} Continuation to respond to when complete.\n// Gracefully stops `drone` instance\n//\nexports.stop = function (cleanup, callback) {\n  if (!callback && typeof cleanup === 'function') {\n    callback = cleanup;\n    cleanup = true;\n  }\n\n  if (!exports.started) {\n    return callback ? callback() : null;\n  }\n\n  exports.started = false;\n  haibu.running.server.close();\n  \n  // Terminate drones\n  haibu.running.drone.destroy(cleanup, callback || function () {});\n  haibu.running = {};\n};","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/drone/drone.js":"/*\n * drone.js: Controls the application lifetime for nodejs applications on a single server.\n *\n * (C) 2010, Nodejitsu Inc.\n *\n */\n\nvar crypto = require('crypto'),\n    fs = require('fs'),\n    path = require('path'),\n    zlib = require('zlib'),\n    tar = require('tar'),\n    haibu = require('../../haibu'),\n    async = haibu.common.async;\n\n//\n// ### function Drone (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Drone resource.\n//\nvar Drone = exports.Drone = function (options) {\n  options = options || {};\n\n  this.apps        = {};\n  this.drones      = {};\n  this.host        = options.host || 'localhost';\n  this.spawner     = new haibu.Spawner(options);\n  this.packagesDir = options.packagesDir || haibu.config.get('directories:packages');\n};\n\n//\n// ### function start (app, callback)\n// #### @app {App} Application to start in this instance.\n// #### @callback {function} Continuation passed to respond to.\n// Attempts to spawn the @app by passing it to the spawner.\n//\nDrone.prototype.start = function (app, callback) {\n  var self = this;\n\n  this.spawner.trySpawn(app, function (err, result) {\n    if (err) {\n      return callback(err, false);\n    }\n    else if (typeof result === 'undefined') {\n      var err = new Error('Unknown error from Spawner.');\n      err.blame = {\n        type: 'system',\n        message: 'Unknown'\n      }\n      return callback(err);\n    }\n    result.hash = app.hash\n    self._add(app, result, function (err) {\n      //\n      // If there is an error persisting the drone\n      // to disk then just respond anyway since the\n      // drone process started correctly.\n      //\n      callback(null, self._formatRecord(result));\n    });\n  });\n};\n\nDrone.prototype.deploy = function (userId, appId, stream, callback) {\n  var untarDir = path.join(this.packagesDir, [userId, appId, Date.now()].join('-')),\n      sha = crypto.createHash('sha1'),\n      self = this;\n  \n  function updateSha (chunk) {\n    sha.update(chunk);\n  }\n  \n  //\n  // Update the shasum for the package being streamed\n  // as it comes in and prehash any buffered chunks.\n  //\n  stream.on('data', updateSha);\n  if (stream.chunks) {\n    stream.chunks.forEach(updateSha);\n  }\n  \n  //\n  // Handle error caused by `zlib.Gunzip` or `tar.Extract` failure\n  //\n  function onError(err) {\n    err.usage = 'tar -cvz . | curl -sSNT- HOST/deploy/USER/APP';\n    err.blame = {\n      type: 'system',\n      message: 'Unable to unpack tarball'\n    };\n    return callback(err);\n  }\n\n  function onEnd() {\n    //\n    // Stop updating the sha since the stream is now closed.\n    //\n    stream.removeListener('data', updateSha);\n\n    //\n    // When decompression is done, then read the `package.json`\n    // file and attempt to start the drone via `this.start()`.\n    //\n    haibu.common.file.readJson(path.join(untarDir, 'package.json'), function (err, pkg) {\n      if (err) {\n        err.usage = 'Submit a tar with a package.json containing a start script'\n        return callback(err);\n      }\n\n      pkg.user = userId;\n      pkg.name = appId;\n      pkg.hash = sha.digest('hex');\n      pkg.repository = {\n        type: 'local',\n        directory: untarDir\n      };\n\n      self.start(pkg, function (err, result) {\n        if (err) {\n          haibu.emit([pkg.user, pkg.name, 'error', 'service'], 'error', err);\n          return callback(err);\n        }\n\n        var record = self.apps[appId];\n        result.hash = pkg.hash;\n        return callback(null, self._formatRecord(record.drones[result.uid], record.app));\n      });\n    });\n  }\n\n  //\n  // Create a temporary directory to untar the streamed data\n  // into and pipe the stream data to a child `tar` process.\n  //\n  fs.mkdir(untarDir, '0755', function (err) {\n    //\n    // Create a tar extractor and pipe incoming stream to it.\n    //\n    stream.pipe(zlib.Gunzip())\n      .on('error', onError)\n      .pipe(new tar.Extract({ path: untarDir }))\n      .on('error', onError)\n      .on('end', onEnd);\n  });\n};\n\n//\n// ### function stop (name, callback)\n// #### @name {string} Name of the application to stop (i.e. app.name).\n// #### @cleanup {bool} (optional) Remove all autostart files (default=true).\n// #### @callback {function} Continuation passed to respond to.\n// Stops all drones with app.name === name managed by this instance\n//\nDrone.prototype.stop = function (name, cleanup, callback) {\n  if (typeof cleanup !== 'boolean') {\n    callback = cleanup;\n    cleanup = true;\n  }\n\n  if (typeof this.apps[name] === 'undefined') {\n    return callback();\n  }\n\n  var self = this,\n      app = this.apps[name],\n      keys = Object.keys(app.drones),\n      results = [];\n\n  function removeAndSave (key, next) {\n    function onStop() {\n      app.drones[key].monitor.removeListener('error', onErr);\n      results.push(app.drones[key].process);\n      self._remove(app, app.drones[key], cleanup, function () {\n        next();\n      });\n    }\n\n    function onErr(err) {\n      //\n      // Remark should we handle errors here\n      //\n      haibu.emit(['drone','stop','error'], {\n        key: key,\n        message: err.message\n      });\n      app.drones[key].monitor.removeListener('stop', onStop);\n      next();\n    }\n\n    app.drones[key].monitor.once('stop', onStop);\n    app.drones[key].monitor.once('error', onErr);\n    try {\n      app.drones[key].monitor.stop(true);\n    }\n    catch (err) {\n      onErr(err);\n    }\n    haibu.emit(['drone','stop','success'], {key: key});\n  }\n\n  async.forEach(keys, removeAndSave, function () {\n    callback(null, results);\n  });\n};\n\n//\n// ### function destroy (cleanup, callback)\n// #### @cleanup {bool} Remove all autostart files.\n// #### @callback {function} Continuation pased to respond to.\n// Stops all drones managed by this instance\n//\nDrone.prototype.destroy = function (cleanup, callback) {\n  var self = this;\n  async.forEach(Object.keys(this.apps), function (name, callback) {\n    self.stop(name, cleanup, callback);\n  }, callback);\n};\n\n//\n// ### function restart (name, callback)\n// #### @name {string} Name of the application to restart (i.e. app.name).\n// Restarts all drones with app = name managed by this instance and\n// responds with the list of processes of new processes.\n//\nDrone.prototype.restart = function (name, callback) {\n  if (!this.apps || !this.apps[name]) {\n    return callback(new Error('Cannot restart application that is not running.'));\n  }\n\n  var self = this,\n      record = this.apps[name],\n      keys = Object.keys(record.drones),\n      processes = [];\n\n  function restartAndUpdate (key, next) {\n    var existing = record.drones[key].monitor.uid;\n\n    record.drones[key].monitor.once('restart', function (_, data) {\n      //\n      // When the `restart` event is raised, update the set of processes for this\n      // app which this `Drone` instance has restarted\n      //\n      processes.push(self._formatRecord(record.drones[data.uid]));\n      next();\n    });\n\n    record.drones[key].monitor.restart();\n  }\n\n  async.forEach(keys, restartAndUpdate, function () {\n    callback(null, processes);\n  });\n};\n\n//\n// ### function clean (app)\n// #### @app {App} Application to clean in this instance.\n// #### @callback {function} Continuation passed to respond to.\n// Stops the potentially running application then removes all dependencies\n// and source files associated with the application.\n//\nDrone.prototype.clean = function (app, callback) {\n  if (!app || !app.user || !app.name) {\n    return callback(new Error('Both `user` and `name` are required.'));\n  }\n\n  var self = this,\n      appsDir = haibu.config.get('directories:apps');\n\n  this.stop(app.name, function (err, result) {\n    //\n    // Ignore errors and continue cleaning\n    //\n    if (err) {\n      haibu.emit('drone:clean:warning', err);\n    }\n    haibu.common.rmApp(appsDir, app, callback);\n  });\n};\n\n//\n// ### function cleanAll ()\n// #### @callback {function} Continuation passed to respond to.\n// Stops all potentially running applications and removes all source code\n// and/or dependencies associated with them from this instance.\n//\nDrone.prototype.cleanAll = function (callback) {\n  var self = this,\n      appsDir = haibu.config.get('directories:apps'),\n      autostartDir = haibu.config.get('directories:autostart');\n\n  function forceStop (name, next) {\n    self.stop(name, function (err) {\n      //\n      // Ignore errors here.\n      //\n      if (err) {\n        haibu.emit('drone:cleanAll:warning', err);\n      }\n      else {\n        haibu.emit('drone:cleanAll:success', name);\n      }\n      next();\n    });\n  }\n\n  async.forEach(Object.keys(this.apps), forceStop, function cleanFiles () {\n    //\n    // Reset `this.apps`, then remove all files in the `apps` and\n    // `autostart` dir(s).\n    //\n    self.apps = {};\n    haibu.emit('drone:cleanAll:end');\n    async.forEach([appsDir, autostartDir], haibu.common.rmApps, callback);\n  });\n};\n\n//\n// ### function update (name, callback)\n// #### @name {string} Name of the application to update (i.e. app.name).\n// Stops an application, Cleans all source and deps, Starts the pplication\n//\nDrone.prototype.update = function (app, callback) {\n  if (!app || !this.apps || !this.apps[app.name]) {\n    return callback(new Error('Cannot update application that is not running.'));\n  }\n\n  var self = this;\n  this.clean(app, function (err) {\n    self.start(app, function (err, result) {\n      callback(err, result);\n    });\n  });\n};\n\n//\n// ### function show (name)\n// #### @name {string} Name of the application to show (i.e. app.name)\n// Shows details for drone with `name` managed by this instance\n//\nDrone.prototype.show = function (name) {\n  var self = this,\n      app = this.apps[name],\n      appData;\n      \n  if (!app) {\n    return undefined;\n  }\n\n  appData = {\n    app: haibu.common.clone(this.apps[name].app),\n    drones: []\n  };\n  appData.app.repository = undefined;\n  \n  if (app.drones) {\n    Object.keys(app.drones).forEach(function (uid) {\n      appData.drones.push(self._formatRecord(app.drones[uid]));\n    });\n  }\n\n  return appData;\n}\n\n//\n// ### function list ()\n// Lists details about all drones managed by this instance\n//\nDrone.prototype.list = function () {\n  var self = this,\n      allApps = {};\n\n  Object.keys(this.apps).forEach(function (name) {\n    allApps[name] = self.show(name);\n  });\n\n  return allApps;\n};\n\nDrone.prototype.running = function () {\n  var self = this,\n      all = [];\n  \n  haibu.common.each(this.list(), function (record) {\n    var app = record.app;\n    haibu.common.each(record.drones, function (drone) {\n      all.push(self.format(app, drone));\n    });\n  });\n  \n  return all;\n};\n\nDrone.prototype.format = function (app, drone) {\n  var hosts = drone.host.split(' '),\n      host2 = hosts.pop(),\n      host1 = hosts.pop();\n\n  return {\n    user:      app.user,\n    name:      app.name,\n    version:   app.version, \n    ctime:     drone.ctime,\n    host:      host1 || host2,\n    host2:     host2,\n    hash:      drone.hash,\n    port:      drone.port,\n    haibuPort: drone.port\n  };\n};\n\n//\n// ### function _autostartFile (app)\n// #### @app {Object} App to create the autostart file for.\n// Returns filename for haibu's persistance (autostart) feature\n//\nDrone.prototype._autostartFile = function (app) {\n  var appname = haibu.common.sanitizeAppname(app.name);\n  return path.join(haibu.config.get('directories:autostart'), appname + '.json');\n};\n\n//\n// ### function _autostartUpdate (action, app, drones, callback)\n// #### @action {'start'|'stop'} Action to perform on the autostart file\n// #### @app {Object} Application to update for autostart\n// #### @drones {Object} Existing drones for the specified `app`.\n// #### @callback {function} Continuation to respond to when complete.\n// Performs the `action` for the autostart file on the specified `app`\n// with the current `drones`.\n//\nDrone.prototype._autostartUpdate = function (action, app, drones, callback) {\n  var _drones = app.drones,\n      autostartFile = this._autostartFile(app),\n      dronesCount = Object.keys(drones).length,\n      appJson;\n\n  app.drones = dronesCount;\n  appJson = JSON.stringify(app);\n  app.drones = _drones;\n\n  // If app has no drones - remove autostart file\n  if (action === 'remove' && dronesCount == 0) {\n    return fs.unlink(autostartFile, callback);\n  }\n\n  function writeFile() {\n    fs.writeFile(autostartFile, appJson, callback);\n  }\n\n  //\n  // Attempt to read any  old `autostartFile`; if it\n  // doesn't exist, overwrite it. Otherwise, update it\n  // based on the `action` supplied.\n  //\n  fs.readFile(autostartFile, function (err, contents) {\n    if (err) {\n      return writeFile();\n    }\n\n    try {\n      contents = JSON.parse(contents.toString());\n    }\n    catch (ex) {\n      return writeFile();\n    }\n\n    //\n    // Update file only if:\n    // action == 'add': drones count less than in new app\n    // action == 'remove': drones count greater than in new app\n    //\n    if (action === 'add' && contents.drones < app.drones ||\n        action === 'remove' && contents.drones > app.drones) {\n      return writeFile();\n    }\n\n    callback();\n  });\n};\n\n//\n// ### function _add (app, drone)\n// #### @app {App} Application for which to attach @drone to\n// #### @drone {Object} Drone to attach to @app\n// Attaches the specified drone to the application in\n// this instance.\n//\nDrone.prototype._add = function (app, drone, callback) {\n  //\n  // Create a record for this app if it doesn't exist\n  //\n  this.apps[app.name] = this.apps[app.name] || {};\n\n  var self = this,\n      record = this.apps[app.name];\n\n  if (!record.app) {\n    //\n    // If we have not yet created a record for this app\n    // then sanitize the data in the app and update the record.\n    //\n    ['domain', 'domains', 'subdomain', 'subdomains'].forEach(function (prop) {\n      if (!app[prop]) {\n        return;\n      }\n\n      if (Array.isArray(app[prop])) {\n        app[prop] = app[prop].map(function (value) {\n          return value.toLowerCase();\n        });\n      }\n      else if (typeof app[prop] === 'string') {\n        app[prop].toLowerCase();\n      }\n    });\n\n    record.app = app;\n    record.drones = {};\n  }\n\n  var uid = drone.monitor.uid;\n  record.drones[uid] = drone;\n\n  //\n  // In the event that the drone unexpectedly restarts,\n  // we need to update the record with the new uid so that\n  // we can control it later on.\n  //\n  drone.monitor.on('restart', function (_, data) {\n    self._update(record, uid, data);\n    uid = data.uid;\n  });\n\n  this._autostartUpdate('add', app, record.drones, callback);\n};\n\n//\n// ### function _remove (a, drone)\n// #### @record {Object} Wrapped {app, drone} tuple set in _add\n// #### @drone {Object} Drone metadata to remove from the specified application\n// #### @cleanup {bool} (optional) Remove all autostart files (default = true).\n// Removes the specified drone object from the bookkeeping of this instance.\n//\nDrone.prototype._remove = function (record, drone, cleanup, callback) {\n  var self = this;\n\n  if (typeof cleanup !== 'boolean') {\n    callback = cleanup;\n    cleanup = true;\n  }\n\n  delete record.drones[drone.monitor.uid];\n\n  //\n  // If there are no more drones for this app\n  // delete the entire app\n  //\n  if (Object.keys(record.drones).length === 0) {\n    delete self.apps[record.app.name];\n  }\n\n  if (cleanup) {\n    this._autostartUpdate('remove', record.app, record.drones, callback);\n  }\n  else {\n    callback();\n  }\n};\n\n//\n// ### function _update (record, existing, update, callback)\n// #### @record {Object} Wrapped {app, drone} tuple set in _add\n// #### @existing {string} Existing uid for the drone to be updated.\n// #### @updated {Object} New forever data for the drone\n// Updates the process information for the uid of the `existing` drone \n// process for the app specified by `records` with the `updated` uid.\n//\nDrone.prototype._update = function (record, existing, updated, callback) {\n  callback = callback || function () {};\n\n  var drone = record.drones[existing];\n  drone.process = drone.monitor.child;\n  drone.data = updated;\n  record.drones[updated.uid] = drone;\n\n  callback();\n};\n\n//\n// ### function _formatRecord (record)\n// #### @record {Object} Record to format.\n// Formats the specified `record` based on the `record.socket`.\n//\nDrone.prototype._formatRecord = function (record, app) {\n  var response = haibu.common.clone(record.data);\n  response.repository = null;\n  \n  if (record.socket && record.socket.port) {\n    response.port = record.socket.port;\n    response.host = record.socket.host;\n    response.hash = record.hash;\n  }\n\n  response.host = response.host || this.host || 'localhost';\n  \n  if (app) {\n    response.name = app.name;\n    response.user = app.user;\n  }\n  \n  return response;\n};\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu-api/lib/client.js":"exports.Drone = exports.Client = require('./client/drone').Drone;\n\nexports.createClient = function (options) {\n  return {\n    drone: new exports.Drone(options)\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu-api/lib/client/drone.js":"/*\n * drone.js: API Client for the haibu Drone API.\n *\n * (C) 2012, Nodejitsu Inc.\n *\n */\n\nvar util = require('util'),\n    request = require('request'),\n    client = require('./client');\n\n//\n// ### function Drone (options)\n// #### @options {Object} Options to use for this instance.\n// Constructor function for the Client to the Haibu server.\n//\nvar Drone = exports.Drone = function (options) {\n  client.Client.call(this, options);\n};\nutil.inherits(Drone, client.Client);\n\n//\n// ### function get (name, callback)\n// #### @name {string} name of the application to get from the Haibu server.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Gets the data about all the drones for the app with the specified `name`\n// on the remote Haibu server.\n//\nDrone.prototype.get = function (name, callback) {\n  this._request('/drones/' + name, callback, function (res, result) {\n    callback(null, result);\n  });\n};\n\n//\n// ### function start (app, callback)\n// #### @app {Object} Application to start on the Haibu server.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Starts the the app with the specified `app.name` on the remote Haibu server.\n//\nDrone.prototype.start = function (app, callback) {\n  this._request({\n    method: 'POST',\n    path: '/drones/' + app.name + '/start',\n    body: { start: app }\n  }, callback, function (res, result) {\n    callback(null, result);\n  });\n};\n\n//\n// ### function stop (name, callback)\n// #### @name {string} Name of the application to stop on the Haibu server.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Stops the application with the specified `name` on the remote Haibu server.\n//\nDrone.prototype.stop = function (name, callback) {\n  this._request({\n    method: 'POST',\n    path: '/drones/' + name + '/stop',\n    body: { stop: { name: name } }\n  }, callback, function (res, result) {\n    callback(null, null);\n  });\n};\n\n//\n// ### function restart (name, callback)\n// #### @name {string} Name of the application to restart on the Haibu server.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Restarts the application with the specified :id on the remote Haibu server.\n//\nDrone.prototype.restart = function (name, callback) {\n  this._request({\n    method: 'POST',\n    path: '/drones/' + name + '/restart',\n    body: { restart: { name: name } }\n  }, callback, function (res, result) {\n    callback(null, result.drones);\n  });\n};\n\n//\n// ### function clean (app, callback)\n// #### @app {Object} Application to clean on the Haibu server.\n// #### @callback {function} Continuation to pass control back to when complete.\n// Attempts to clean the specified `app` from the Haibu server targeted by this instance.\n//\nDrone.prototype.clean = function (app, callback) {\n  this._request({\n    method: 'POST',\n    path: '/drones/' + app.name + '/clean',\n    body: app\n  }, callback, function (res, result) {\n    callback(null, result);\n  });\n};\n\n//\n// ### function cleanAll (app, callback)\n// #### @callback {function} Continuation to pass control back to when complete.\n// Attempts to clean the all applications from the Haibu server targeted by this instance.\n//\nDrone.prototype.cleanAll = function (callback) {\n  this._request({\n    method: 'POST',\n    path: '/drones/cleanall'\n  }, callback, function (res) {\n    callback();\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu-api/lib/client/client.js":"/*\n * client.js: Client for the haibu API\n *\n * (C) 2012, Nodejitsu Inc.\n *\n */\n \nvar request = require('request'),\n    base64 = require('utile').base64;\n\n//\n// ### function Client (options)\n// #### @options {Object} Options to use for this instance.\n// Constructor function for the Client to the haibu API.\n//\nvar Client = exports.Client = function (options) {\n  this.options = options || {};\n    \n  if (typeof this.options.get !== 'function') {\n    this.options.get = function (key) {\n      return this[key];\n    };\n  }\n  \n  this.config = {\n    host: options.host || 'localhost',\n    port: options.port || 9002\n  };\n};\n\nClient.prototype.failCodes = {\n  400: 'Bad Request',\n  401: 'Not authorized',\n  403: 'Forbidden',\n  404: 'Item not found',\n  500: 'Internal Server Error'\n};\n\nClient.prototype.successCodes = {\n  200: 'OK',\n  201: 'Created'\n};\n\n//\n// ### @remoteUri {string}\n// Full URI for the remote Haibu server this client\n// is configured to request against.\n//\nClient.prototype.__defineGetter__('remoteUri', function () {\n  return 'http://' + this.config.host + ':' + this.config.port;\n});\n\n//\n// ### @private _request (method, uri, [body], callback, success)\n// #### @options {Object} Outgoing request options.\n// #### @callback {function} Continuation to short-circuit to if request is unsuccessful.\n// #### @success {function} Continuation to call if the request is successful\n// Core method for making requests against the haibu Drone API. Flexible with respect\n// to continuation passing given success and callback.\n//\nClient.prototype._request = function (options, callback, success) {\n  var self = this;\n  \n  if (typeof options === 'string') {\n    options = { path: options };\n  }\n  \n  options.method  = options.method || 'GET';\n  options.uri     = this.remoteUri + options.path;\n  options.headers = options.headers || {};\n  options.headers['content-type'] = options.headers['content-type'] || 'application/json';\n    \n  if (options.headers['content-type'] === 'application/json'\n    && options.body) {\n    options.body = JSON.stringify(options.body);\n  }\n\n  return request(options, function (err, response, body) {\n    if (err) {\n      return callback(err);\n    }\n\n    var statusCode = response.statusCode.toString(),\n        result,\n        error;\n        \n    try {\n      result = JSON.parse(body);\n    }\n    catch (ex) {\n      // Ignore Errors\n    }\n    \n    if (Object.keys(self.failCodes).indexOf(statusCode) !== -1) {\n      error = new Error('haibu Error (' + statusCode + '): ' + self.failCodes[statusCode]);\n      error.result = result;\n      error.status = statusCode;\n      return callback(error);\n    }\n\n    success(response, result);\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/plugins/coffee.js":"var coffee = exports;\n\ncoffee.name = 'coffee';\n\ncoffee.init = function (done) {\n  done();\n};\n\ncoffee.attach = function attach(options) {\n}\n\ncoffee.argv = function argv(repo) {\n  if (repo.executable === 'coffee') {\n    return {\n      argv: ['--plugin', 'coffee', '--coffee', 'true']\n    }\n  }\n  return {\n    argv: ['--plugin', 'coffee']\n  }\n}","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/plugins/advanced-replies.js":"var haibu = require('../../haibu'),\n  _sendResponse = haibu.sendResponse,\n  fs = require('fs'),\n  exec = require('child_process').exec,\n  serverName = (fs.readFileSync('/etc/hostname') + '').trim();\n\n  \nvar replies = exports;\n\nreplies.name = 'advanced-replies';\n\nreplies.init = function (done) {\n  done();\n};\n\nreplies.attach = function attach() {\n  haibu.sendResponse = function sendResponse(res, status, body) {\n    var that = this, $args = arguments;\n    body.time = Date.now();\n    body.server = serverName;\n    //\n    // TODO: Is there a way to be notified when IP changes?\n    //  Doing this every time is a bit odd.\n    //\n    exec('ifconfig | grep \\'inet addr:\\' | grep -v \\'127.0.0.1\\' | cut -d: -f2 | awk \\'{ print $1}\\'', function (err, stdout, stderr) {    \n      body.ips = (stdout + '').trim();\n      return _sendResponse.apply(that, $args);\n    })\n  }\n}","/home/travis/build/npmtest/node-npmtest-haibu/node_modules/haibu/lib/haibu/plugins/useraccounts.js":"\nvar fs = require('fs'),\n    path = require('path'),\n    spawn = require('child_process').spawn,\n    async = require('flatiron').common.async,\n    haibu = require('../../haibu');\n\nvar useraccounts = exports;\n\nfunction makeNPMConfiguration(dir, target, callback) {\n  async.parallel([\n    //\n    // Make the .npm folder for the npm cache\n    //\n    function makeDotNpm(next) {\n      haibu.utils.mkdirp(path.join(dir, '..', '.npm'), next)\n    },\n    //\n    // Make the .tmp folder for temporary npm files\n    //\n    function makeDotTmp(next) {\n      haibu.utils.mkdirp(path.join(dir, '..', '.tmp'), next)\n    },\n    //\n    // Create an empty .userconfig and .globalconfig for npm\n    //\n    async.apply(fs.writeFile, path.join(dir, '..', '.userconfig'), ''),\n    async.apply(fs.writeFile, path.join(dir, '..', '.globalconfig'), '')\n  ], function (err) {\n    if (err) return callback(err);\n    var child = spawn('chown',['-R',haibu.config.get('useraccounts:prefix') + target.user,'.'], {cwd:path.join(dir,'..','..')});\n    child.on('exit', function (code) {\n      callback(code ? new Error('Unable to change permissions on npm configuration') : null);\n    });\n  });  \n}\n\nvar _spawnOptions = haibu.getSpawnOptions;\nhaibu.getSpawnOptions = function getSpawnOptions(target) {\n  var options = _spawnOptions.apply(this, arguments);\n  options.env.USER = haibu.config.get('useraccounts:prefix') + target.user;\n  options.env.HOME = path.join(haibu.config.get('directories:apps'), target.user);\n  options.env.TEMP = path.join(options.env.HOME, target.name, '.tmp');\n  options.env.TMPDIR = path.join(options.env.HOME, target.name, '.tmp');\n  return options;\n}\n\nfunction spawnNPM(dir, target, callback) {\n  var noNpm = haibu.config.get('no-npm'),\n      appDir = dir,\n      stderr = '',\n      args,\n      meta;\n\n  if (noNpm === true) {\n    return callback(null, []);\n  }\n  \n  meta = {\n    app: target.name,\n    user: target.user,\n    dependencies: target.dependencies\n  };\n  if (typeof target.dependencies === 'undefined' || Object.keys(target.dependencies).length === 0) {\n    haibu.emit('npm:install:none', 'info', meta);\n    callback(null, []);\n    return;\n  }\n  \n  haibu.emit('npm:install:start', 'info', meta);\n  \n  function spawnNpm (err) {\n    try {\n      var spawnOptions = haibu.getSpawnOptions(target);\n    }\n    catch (e) {\n      callback(e);\n      return;\n    }\n    args = [\n      '-u',\n      haibu.config.get('useraccounts:prefix') + target.user,\n      'npm',\n      // package.json scripts freak out from node-pack in some versions, sudo -u + this are workaround\n      '--unsafe-perm', 'true',\n      //only use cache for app\n      '--cache', path.join(dir,'..','.npm'),\n      //use blank or non-existent user config\n      '--userconfig', path.join(dir,'..','.userconfig'),\n      //use non-existant user config\n      '--globalconfig', path.join(dir,'..','.globalconfig'),\n      '--production',\n      'install'\n    ];\n    \n    haibu.emit('npm:install:args', 'info', { args: args })\n    spawnOptions.cwd = dir;\n    child = spawn('sudo', args, spawnOptions);\n    \n    //\n    // Kill NPM if this takes more than 5 minutes\n    //\n    setTimeout(child.kill.bind(child, 'SIGKILL'), 5 * 60 * 1000);\n    \n    child.stdout.on('data', function (data) {\n      haibu.emit('npm:install:stdout', 'info', {\n        data: data+'',\n        meta: meta\n      });\n    });\n\n    child.stderr.on('data', function (data) {\n      stderr += data;\n      haibu.emit('npm:install:stderr', 'info', {\n        data: data+'',\n        meta: meta\n      });\n    });\n\n    child.on('exit', function (code) {\n      if (code || code == null) {\n        var err = new Error('NPM Install failed');\n        err.code = code;\n        err.result = stderr;\n        err.blame = {\n          type: 'user',\n          message: 'NPM failed to install dependencies'\n        };\n\n        haibu.emit('npm:install:failure', 'info', {\n          code: code,\n          meta: meta\n        });\n\n        callback(err);\n        return;\n      }\n\n      haibu.emit('npm:install:success', 'info', meta);\n      callback();\n    });\n  }\n  \n  function rewritePackage(done) {\n    var pkgFile = path.join(appDir, 'package.json');\n    fs.readFile(pkgFile, 'utf8', function (err, data) {\n      if (err) {\n        //\n        // TODO: Write a stripped down version of the package in memory\n        // if no package exists on disk.\n        //\n        done(err);\n        return;\n      }\n      \n      var pkg;\n      try {\n        pkg = JSON.parse(data);\n      }\n      catch (ex) {\n        //\n        // TODO: Write a stripped down version of the package in memory\n        // if there is an error in the package.json on disk.\n        //\n        done(err);\n        return;\n      }\n      \n      pkg.dependencies = target.dependencies;\n      fs.writeFile(pkgFile, JSON.stringify(pkg, null, 2), 'utf8', done);\n    });\n  }\n  \n  //\n  // Rewrite the package.json in the chroot'ed app dir\n  // and then invoke `npm install`.\n  //\n  rewritePackage(spawnNpm);\n};\n\nhaibu.common.npm.install = function (dir, target, callback) {\n  makeNPMConfiguration(dir, target, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n    spawnNPM(dir, target, callback);\n  })\n};\n\nuseraccounts.name = 'useraccounts';\n\nuseraccounts.argv = function (repo) {\n  var user = repo.app.user;\n  return { argv: ['--plugin',\n        'setuid',\n        '--setuid',\n        haibu.config.get('useraccounts:prefix') + user] };\n}\n\nuseraccounts.attach = function (options) {\n  if (process.getuid() !== 0) {\n    throw new Error('useraccounts plugin requires admin privileges.');\n  }\n  \n  haibu.config.set('useraccounts:prefix', 'haibu-');\n  \n  \n  var _install = haibu.common.npm.install;\n  haibu.common.npm.install = function install(dir, target, callback) {\n    var self = this;\n\n    var env = {};\n    for(var k in process.env) {\n      env[k] = process.env[k];\n    }\n\n    var user = env.USER = haibu.config.get('useraccounts:prefix') + target.user;\n    var appdir = env.HOME = path.join(haibu.config.get('directories:apps'), target.user);\n    var child = spawn('bash', [path.join(__dirname, '..', 'common', 'adduser.sh')], {\n        env: env\n     });\n    child.on('exit', function (code) {\n        haibu.emit('useraccounts:adduser:exit', 'info', {\n           exitCode: code\n        })\n        if (code === 0) {\n          _install.call(self, dir, target, changePermissions);\n        }\n        else {\n           callback(new Error('Unable to create user'));\n        }\n    });\n    \n    function changePermissions(err) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      spawn('chown', ['-R', user + ':nogroup', appdir + '/' + target.name]).on('exit', function (exitCode) {\n        haibu.emit('useraccounts:chown:exit', 'info', {\n           exitCode: exitCode\n        })\n        if (exitCode) {\n          callback(new Error('Unable to grab ownership for files'));\n        }\n        else {\n          spawn('chmod', ['-R', '777', appdir]).on('exit', function (exitCode) {\n            haibu.emit('useraccounts:chmod:exit', 'info', {\n               exitCode: exitCode\n            })\n            if (exitCode) {\n              callback(new Error('Unable to change permissions for files'));\n            }\n            else {\n              callback();\n            }\n          });\n        }\n      });\n    }\n  }\n};\n\nuseraccounts.init = function (done) {\n  done();\n};\n"}